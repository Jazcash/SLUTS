// Manually transcribed from https://springrts.com/dl/LobbyProtocol/ProtocolDescription.html

export interface SpringLobbyProtocol {
    Request: {
        /**
         * Requests a PONG back from the server.
         *
         * Clients should send PING once every 30 seconds, if no other data is being sent to the server. For details, see the notes above on keep-alive signals.
         */
        PING: {
        }
        /** Initiate a TLS connection to the server. */
        STLS: {
        }
        /** Clients should send this as their last command before severing their connection to the server, to notify a clean and deliberate disconnect. */
        EXIT: {
            /** Clients may optionally specify a reason for quitting. If the user simply wished to exit, many lobby clients send their name and version. */
            reason?: string;
        }
        /**
         * The client sends this command when trying to register a new account. Note that the client must not already be logged in, or else the server will deny his request.
         *
         * The username and password are given sanity/uniqueness checks, and these primarily determine the servers response. If email verification is enabled, and no valid email address is provided, the server will deny the registration.
         */
        REGISTER: {
            userName: string;
            /** The user's password string. If a client uses a secure session (which means the command itself shall be encrypted, including its arguments), it should send BASE64(password), otherwise it should send BASE64(MD5(password)). */
            password: string;
            /** A valid email address. Case will not be considered. */
            email?: string;
        }
        /**
         * Sent by a client asking to log on to the server.
         *
         * Note: if the client has not yet confirmed the user agreement, then server will send the AGREEMENT to the client as a response to this command. In this case the response to LOGIN will be delayed until after CONFIRMAGREEMENT.
         *
         * Also see LOGININFOEND command.
         */
        LOGIN: {
            userName: string;
            /** The user's password string. If a client uses a secure session (which means the command itself shall be encrypted, including its arguments), it should send BASE64(password), otherwise it should send BASE64(MD5(password)). */
            password: string;
            /** @deprecated Always 0 */
            cpu: 0;
            /** The client should supply his local IP (e.g. 192.168.x.y, or whatever it uses) so the server can forward local IPs to clients behind the same NAT (this resolves some of the host/joining issues). If the client is unable to determine its local IP, he should send "*" instead. */
            localIP: string;
            lobbyNameAndVersion: string;
            /** This is a unique user identification number provided by the client-side software. It has to be an unsigned 32 bit integer which is generated by calculating the crc32 from the binary mac address of the primary network interface. If it can't be determinated it has to be set to 0. */
            userID?: number;
            /** When connecting, the lobby client can tell the lobby server that it is compatible with some optional functionalities that break backward compatibility. Each flag in this space separated parameter indicates a specific functionality (like IRC user/channel flags). By default, all the optional functionalities are considered as not supported by the client. For the current list of flags, see the section on recent changes. */
            compFlags?: string[];
        }
        /** Confirm that the user agreed to the user agreement, and supply an email verification code (if necessary). */
        CONFIRMAGREEMENT: {
            verificationCode: string;
        }
        /** Will rename the current account name to newUsername. The user has to be logged in for this to work. After the server renames the account, it will disconnect the client. */
        RENAMEACCOUNT: {
            newUsername: string;
        }
        /** Will change the password of the users's account. */
        CHANGEPASSWORD: {
            oldPassword: string;
            newPassword: string;
        }
        /**
         * Requests a verification code, to be sent to a new email address that the user wishes to associate to their account.
         *
         * Even if email verification is disabled, it is intended that the client will call this before calling CHANGEEMAIL. If email verification is disabled, the response will be a CHANGEEMAILREQUESTDENIED, containing a message informing the user that a blank verification code will be accepted.
         */
        CHANGEEMAILREQUEST: {
            /** The email address the user wishes to change too. */
            newEmail: string;
        }
        /** Asks the server to change the email address associated to the client. See also CHANGEEMAILREQUEST, which would typically be called first. */
        CHANGEEMAIL: {
            /** The email address the user wishes to change too. */
            newEmail: string;
            /** The verification code recieved as a result of CHANGEEMAILREQUESTACCEPTED. */
            verificationCode: string;
        }
        /** Request that an active verification code to be re-sent. */
        RESENDVERIFICATION: {
            /** The email address the user wished to change too, or register with, but has forgotten/lost/eaten or not recieved their verification code for. */
            newEmail: string;
        }
        /** Requests a verification code, to be sent to the email address of a user wishing to reset their password. */
        RESETPASSWORDREQUEST: {
            /** The email address associated to the acccount. */
            email: string;
        }
        /** */
        RESETPASSWORD: {
            /** The email address the user wishes to change too. */
            email: string;
            /** The verification code recieved as a result of RESETPASSWORDREQUESTACCEPTED. */
            verificationCode: string;
        }
        /** Sent by a client when requesting the list of all channels on the server */
        CHANNELS: {

        }
        /** Sent by a client requesting to join a channel. */
        JOIN: {
            chanName: string;
            /** If the channel is locked, non-priviledged clients must supply the correct key to join. */
            key?: string;
        }
        /** A request to change a channel's topic, typically sent by a priviledged user. */
        CHANNELTOPIC: {
            chanName: string;
            topic: string;
        }
        /**
         * Sent by a client when requesting to leave a channel.
         *
         * Note that when the client is disconnected, the client is automatically removed from all channels.
         */
        LEAVE: {
            chanName: string;
        }
        /** Send a chat message to a specific channel. The client has to join the channel first, to be allowed to use this command. */
        SAY: {
            chanName: string;
            message: string;
        }
        /** Sent by any client requesting to say something in a channel in "/me" IRC style. (The SAY command is used for normal chat messages.) */
        SAYEX: {
            chanName: string;
            message: string;
        }
        /** Send a private chat message to an other client. */
        SAYPRIVATE: {
            userName: string;
            message: string;
        }
        /** Sent by a client requesting to say something in "/me" IRC style in a private message. (Normal chat messages are sent via the SAYPRIVATE command.) */
        SAYPRIVATEEX: {
            userName: string;
            message: string;
        }
        /** Sent by a client requesting the history of a channel, since the lastID. */
        GETCHANNELMESSAGES: {
            chanName: string;
            lastId: number;
        }
        /** Sent by a bridge bot notifying the server of a new bridged client. */
        BRIDGECLIENTFROM: {
            /** 'discord', for example. Battle hosts bridging ingame users should use their own name username as the location. */
            location: string;
            /** A string which unqiuely identifies the external client, within its specified location, and which will not change if the external client changes username. */
            externalId: number;
            /** The current username of the external client, in its external location. */
            externalUsername: string;
        }
        /** Sent by a bridge bot notifying the server that a bridged client has left the bridge. */
        UNBRIDGECLIENTFROM: {
            location: string;
            externalId: number;
        }
        /** Send by a bridge bot requesting to join a bridged client to a channel. */
        JOINFROM: {
            chan: string;
            location: string;
            externalId: number;
        }
        /** Sent by a bridge bot requesting to remove a bridged client from a channel. */
        LEAVEFROM: {
            chan: string;
            location: string;
            externalId: number;
        }
        /** Sent by a bridge bot to notify that a bridged user spoke into a channel. */
        SAYFROM: {
            chan: string;
            location: string;
            externalId: number;
            message: string;
        }
        /**
         * Sent by the client requesting to open a new battle. If the command is successful, the client becomes the founder (i.e. host) of the new battle.
         *
         * Clients without botflags will have their maxPlayers capped at 10; the founding client will be informed via a server message if the server applies this limitation.
         */
        OPENBATTLE: {
            type: number;
            natType: number;
            /** Must be "*" if founder does not wish to have password-protected game. */
            password: string;
            port: number;
            maxPlayers: number;
            /** A signed 32-bit integer (acquired via the unitsync library). */
            gameHash: number;
            /** The minimum rank required for a client in the battle to be allowed to become a player. */
            rank: number;
            /** A signed 32-bit integer (acquired via the unitsync library). */
            mapHash: number;
            /** Use 'Spring' */
            engineName: string;
            /** For example: '94.1.1-1062-g9d16c2d develop', same format as in TASSERVER */
            engineVersion: string;
            map: string;
            title: string;
            gameName: string;
        }
        /** Sent by a client requesting to join a battle. */
        JOINBATTLE: {
            battleId: number;
            password: string;
            /** A random, client-generated string (which is used to avoid account spoofing ingame, and will appear in script.txt). Note that if this argument is sent, a password must be sent too. If the battle is not passworded then an empty password should be sent. */
            scriptPassword?: string;
        }
        /** Sent by a battle host, in response to a JOINBATTLEREQUEST command, instructing the server to allow the user to join their battle. */
        JOINBATTLEACCEPT: {
            userName: string;
        }
        /** Sent by a battle host, in response to a JOINBATTLEREQUEST command, instructing the server to disallow the user to join their battle. */
        JOINBATTLEDENY: {
            userName: string;
            reason?: string;
        }
        /**
         * Sent by the client when he leaves a battle.
         *
         * When this command is by the founder of a battle, it notifies that the battle is now closed.
         */
        LEAVEBATTLE: {
        }
        /** Sent by the founder of the battle, telling the server that some of the "external" parameters of the battle changed. */
        UPDATEBATTLEINFO: {
            spectatorCount: number;
            /** A boolean ("0" (for false) or "1"). Note that when the client creates a battle, the server assumes it is unlocked (by default). The client must make sure it assumes this same default. */
            locked: boolean;
            /** A signed 32-bit integer. See the OPENBATTLE command for more info. */
            mapHash: number;
            /** Must NOT contain the file extension! */
            mapName: string;
        }
        /**
         * Sent by a client to inform the server about his changed status.
         *
         * Note: To tell out if a battle is "in-game", a client must check the in-game status of the host.
         */
        MYSTATUS: {
            /**
             * A signed integer in text form (e.g. "1234"). Each bit has its meaning:
             * - b0 = in game (0 - normal, 1 - in game)
             * - b1 = away status (0 - normal, 1 - away)
             * - b2-b4 = rank (see Account class implementation for description of rank) - client is not allowed to change rank bits himself (only server may set them).
             * - b5 = access status (tells us whether this client is a server moderator or not) - client is not allowed to change this bit himself (only server may set them).
             * - b6 = bot mode (0 - normal user, 1 - automated bot). This bit is copied from user's account and can not be changed by the client himself. Bots differ from human players in that they are fully automated and that some anti-flood limitations do not apply to them.
             */
            status: string;
        }
        /**
         * Sent by a client to the server, telling him his battle status changed.
         * */
        MYBATTLESTATUS: {
            /**
             * An integer, but with limited range: 0..2147483647 (use signed int and consider only positive values and zero) This number is sent as text. Each bit has its meaning:
             *
             * - b0 = undefined (reserved for future use)
             * - b1 = ready (0=not ready, 1=ready)
             * - b2..b5 = team no. (from 0 to 15. b2 is LSB, b5 is MSB)
             * - b6..b9 = ally team no. (from 0 to 15. b6 is LSB, b9 is MSB)
             * - b10 = mode (0 = spectator, 1 = normal player)
             * - b11..b17 = handicap (7-bit number. Must be in range 0..100). Note: Only host can change handicap values of the players in the battle (with HANDICAP command). These 7 bits are always ignored in this command. They can only be changed using HANDICAP command.
             * - b18..b21 = reserved for future use (with pre 0.71 versions these bits were used for team color index)
             * - b22..b23 = sync status (0 = unknown, 1 = synced, 2 = unsynced)
             * - b24..b27 = side (e.g.: arm, core, tll, ... Side index can be between 0 and 15, inclusive)
             * - b28..b31 = undefined (reserved for future use)
             */
            battleStatus: string;
            /** Should be a 32-bit signed integer in decimal form (e.g. 255 and not FF) where each color channel should occupy 1 byte (e.g. in hexdecimal: $00BBGGRR, B = blue, G = green, R = red). Example: 255 stands for $000000FF. */
            myTeamColor: number;
        }
        /**
         * Sent by the founder of the battle when changing a user's handicap value (which is part of that users battle status).
         *
         * Only the founder can change other users handicap values, and that requests from non-founder users will be ignored.
         */
        HANDICAP: {
            userName: string;
            /** Must be in range [0, 100] (inclusive). */
            value: number;
        }
        /** Sent by the founder of the battle, to tell the server to kick a client from the battle. The server removes the target client from the battle and notifies the target client via FORCEQUITBATTLE command. */
        KICKFROMBATTLE: {
            userName: string;
        }
        /** Sent by the founder of a battle to change the team number of a user. The server will update the client's battle status automatically. */
        FORCETEAMNO: {
            userName: string;
            teamNo: number;
        }
        /** Sent by the founder of a battle to change the ally team number of a user. The server will update the client's battle status automatically. */
        FORCEALLYNO: {
            userName: string;
            teamNo: number;
        }
        /** Sent by the founder of a battle to change the team colour of a team. The server will update the client's battle status automatically. */
        FORCETEAMCOLOR: {
            userName: string;
            /** Should be a 32-bit signed integer in decimal form (e.g. 255 and not FF) where each color channel should occupy 1 byte (e.g. in hexdecimal: $00BBGGRR, B = blue, G = green, R = red). Example: 255 stands for $000000FF. */
            color: number;
        }
        /** Sent by the founder of a battle to force a given user to become a spectator. The server will update the client's battle status automatically. */
        FORCESPECTATORMODE: {
            userName: string;
        }
        /** Sent by the founder of a battle to tell the server that one or more units are now disabled. The server will update the client's battle status automatically. */
        DISABLEUNITS: {
            unitNames: string[];
        }
        /** Sent by the founder of a battle to tell the server that one or more units are now enabled. The server will update the client's battle status automatically. */
        ENABLEUNITS: {
            unitNames: string[];
        }
        /** Sent by the founder of a battle, telling the server that he enabled ALL units and, and is thus clearing the disabled units list. */
        ENABLEALLUNITS: {
        }
        /** Sent to request that a "ring" sound to be played to other user. */
        RING: {
            userName: string;
        }
        /** Allows a client to add a bot to the battle. */
        ADDBOT: {
            name: string;
            battleStatus: string;
            /** Should be a 32-bit signed integer in decimal form (e.g. 255 and not FF) where each color channel should occupy 1 byte (e.g. in hexdecimal: $00BBGGRR, B = blue, G = green, R = red). */
            teamColor: number;
            aiDll: string;
        }
        /** Removes a bot from the battle. */
        REMOVEBOT: {
        }
        /** Sent by a client when he is trying to update the status of a bot. Only the bot owner and battle host may update a bot's status. */
        UPDATEBOT: {
            name: string;
            /** Similar to that of the normal client's, see MYBATTLESTATUS for more info. */
            battleStatus: string;
            /** Should be a 32-bit signed integer in decimal form (e.g. 255 and not FF) where each color channel should occupy 1 byte (e.g. in hexdecimal: $00BBGGRR, B = blue, G = green, R = red). */
            teamColor: number;
        }
        /** Adds a start rectangle for the 'allyno' ally team. Only the battle foudner may use this command. See lobby client implementations and Spring docs for more info on this one. "left", "top", "right" and "bottom" refer to a virtual rectangle that is 200x200 in size, where coordinates should be in the interval [0, 200]. */
        ADDSTARTRECT: {
            allyNo: number;
            left: number;
            top: number;
            right: number;
            bottom: number;
        }
        /** Removing a start rectangle the for 'allyNo' ally team. Sent by the host of the battle. See client implementations and Spring docs for more info on this one. */
        REMOVESTARTRECT: {
            allyNo: number;
        }
        /**
         * Sent by a client (battle host), to inform other clients about current battle configuration (start positions type, mod options, map options...). Only the battle host itself needs to write the corresponding script tags into script.txt, other battle clients should merely use them for display purposes. The [pair] format is "key=value can have spaces". Keys may not contain spaces, and are expected to use the '/' character to separate tables, see example:
         *
         * - SETSCRIPTTAGS game/startmetal=1000
         * - SETSCRIPTTAGS game/startenergy=1000
         * - SETSCRIPTTAGS game/maxunits=500
         * - SETSCRIPTTAGS game/startpostype=1
         * - SETSCRIPTTAGS game/gamemode=0
         * - SETSCRIPTTAGS game/limitdgun=1
         * - SETSCRIPTTAGS game/diminishingmms=0
         * - SETSCRIPTTAGS game/ghostedbuildings=1
         *
         * Though in reality, all tags are joined together in a single command. Note that when specifying multiple key+value pairs, they must be separated by TAB characters. All keys are made lowercase by the server. See the examples bellow.
         */
        SETSCRIPTTAGS: {
            pairs: string[];
        }
        /** Sent by a client (battle host), to inform other clients that a battle configuration setting has been removed (this is mainly usefull when changing map with map options). */
        REMOVESCRIPTTAGS: {
            keys: string[];
        }
        /** Tells the server to add the user to the client's ignore list. Doing this will prevent any SAID*, SAY* and RING commands to be received from the ignored user. This command uses named arguments, see "Named Arguments" chapter of the Intro section. */
        IGNORE: {
            /** The username of the ignored user. */
            userName: string;
            /** Reason for the ignore. */
            reason?: string;
        }
        /** Tells the server to remove the user to the client's ignore list. Also see the IGNORE command. This command uses named arguments, see "Named Arguments" chapter of the Intro section. */
        UNIGNORE: {
            userName: string;
        }
        /** Sent by a client when requesting its ignore list. */
        IGNORELIST: {
        }
        /** A client may send this command after it has received TASSERVER to query the server for supported comp-flags that may be specified on LOGIN. */
        LISTCOMPFLAGS: {
        }
        /** This command posts a message in particular channels, calling for players. It is currently the (only) test case for a client command used JSON format. */
        PROMOTE: {
        }
    };

    Response: {
        /** Sent as the response to a PING command. */
        PONG: {
        }
        /** Sent as the response to a STLS command. The client now can now start the tls connection. The server will send again the greeting TASSERVER. */
        OK: {
        }
        /** This is the first message (i.e. "greeting message") that a client receives upon connecting to the server. */
        TASSERVER: {
            /** This is the lobby protocol version used by the server. The client may check if it supports this version before attempting to log in. */
            protocolVersion: string;
            /**
             * Default spring version used on lobby server. Can be locally determinated by calling unitsyncs GetSpringVersion(), IsSpringReleaseVersion() and GetSpringVersionPatchset(), which will return the version, for example "95.0" or "94.1.1-1062-g9d16c2d develop".
             *
             * Note that if the value of this parameter is "*", the client should simply ignore it since this means that the server does not contain any updates nor does it require latest Spring version (this is usually the case when the server is running in LAN mode). */
            springVersion: string;
            /** This is server UDP port where the "NAT Help Server" is running. This is the port to which clients should send their UDP packets when trying to figure out their public UDP source port. This is used with some NAT traversal techniques (e.g. "hole punching"). */
            udpPort: number;
            /** Tells what mode the server is in. */
            serverMode: number;
        }
        /** Sent in response to a REGISTER command, if registration has been refused. */
        REGISTRATIONDENIED: {
            reason?: string;
        }
        /**
         * Sent in response to a REGISTER command, if registration has been accepted.
         *
         * If email verification is enabled, sending of this command notifies that the server has sent a verification code to the users email address. This verification code is expected back from the client in CONFIRMAGREEMENT
         *
         * Upon reciept of this command, a lobby client would normally be expected to reply with a LOGIN attempt (but this is not a requirement of the protocol).
         */
        REGISTRATIONACCEPTED: {
        }
        /**
         * Sent as a response to the LOGIN command, if it succeeded. Next, the server will send much info about clients and battles:
         * - multiple MOTD, each giving one line of the current welcome message
         * - multiple ADDUSER, listing all users currently logged in
         * - multiple BATTLEOPENED, UPDATEBATTLEINFO, detailing the state of all currently open battles
         * - multiple JOINEDBATTLE, indiciating the clients present in each battle
         * - multiple CLIENTSTATUS, detailing the statuses of all currently logged in users
         *
         * Finally, it will send a LOGININFOEND command indicating that it has finished sending all this info. Note that, except for this final command, the commands/info listed above may be sent to the client in any order.
         */
        ACCEPTED: {
            userName: string;
        }
        /** Sent as a response to a failed LOGIN command. */
        DENIED: {
            reason: string;
        }
        /** Sent by the server, indicating that it has finished sending the login info, completing the sequence initiated by ACCEPTED */
        LOGININFOEND: {
        }
        /**
         * Sent by the server upon receiving a LOGIN command, if the client has not yet agreed to the server's "terms-of-use". The server may send multiple AGREEMENT commands, each of corresponds to a new line in the agreement text, finishing with an AGREEMENTEND command. The client should send CONFIRMAGREEMENT and then resend the LOGIN command, or disconnect from the server if he has chosen to refuse the agreement.
         */
        AGREEMENT: {
            /** The user agreement is sent in "Text" format (.txt file streamed via socket). */
            agreement: string;
        }
        /** Sent by the server after multiple AGREEMENT commands. This way, the server tells the client that he has finished sending the agreement (this is the time when the lobby client should popup the "agreement" screen and wait for the user to accept/reject it). */
        AGREEMENTEND: {
        }
        /** Sent by the server after ACCEPTED. The server may send multiple MOTD commands, each MOTD corresponds to one line of the current welcome message. */
        MOTD: {
            message: string;
        }
        /** Notifies that a verification code was sent, in response to CHANGEEMAILREQUEST.
         *
         * No response is required from the client, although a CHANGEEMAIL command would normally be sent once the user has supplied their verification code. */
        CHANGEEMAILREQUESTACCEPTED: {

        }
        /** Notifies that a verification code was not sent, in response to CHANGEEMAILREQUEST. */
        CHANGEEMAILREQUESTDENIED: {
            errorMsg: string;
        }
        /** Notifies that client that their email address was changed, in response to CHANGEEMAIL. */
        CHANGEEMAILACCEPTED: {

        }
        /** Notifies that the email address could not be changed, in response to CHANGEEMAIL. */
        CHANGEEMAILDENIED : {
            errorMsg: string;
        }
        /** Notifies that a verification code was re-sent, in response to RESENDVERIFICATION. */
        RESENDVERIFICATIONACCEPTED: {
        }
        /** Notifies that a verification code was not re-sent, in response to RESENDVERIFICATION. */
        RESENDVERIFICATIONDENIED: {
            errorMsg: string;
        }
        /** Notifies that a verification code was sent, in response to RESETPASSWORDREQUEST.
         * No response is required from the client, although a RESETPASSWORD command would normally be sent.
         **/
        RESETPASSWORDREQUESTACCEPTED: {
        }
        /** Notifies that a verification code was not sent, in response to RESETPASSWORDREQUEST. */
        RESETPASSWORDREQUESTDENIED: {
            errorMsg: string;
        }
        /** Notifies that client that their password was changed, in response to RESETPASSWORD. The new password will be emailed to the client. */
        RESETPASSWORDACCEPTED: {
        }
        /** Notifies that the password could not be changed, in response to RESETPASSWORD. */
        RESETPASSWORDDENIED: {
            errorMsg: string;
        }
        /** Tells the client that a new user joined a server. The client should add this user to his clients list, which he must maintain while he is connected to the server. */
        ADDUSER: {
            userName: string;
            /** A two-character country code based on ISO 3166 standard. See http://www.iso.org/iso/en/prods-services/iso3166ma/index.html */
            country: string;
            /** @deprecated see the LOGIN command. */
            cpu: 0;
            userId: number;
            /** A string of text sent by the client, typically identifying the lobby client they are using. */
            lobbyId: number;
        }
        /** Indicates that a user disconnected from the server. The client should remove this user from his clients list, which he must maintain while he is connected to the server. */
        REMOVEUSER: {
            userName: string;
        }
        /** A general purpose message sent by the server. The lobby client program should display this message to the user in a non-invasive way, but clearly visible to the user (for example, as a SAYEX-style message from the server, printed into all the users chat panels). */
        SERVERMSG: {
            message: string;
        }
        /** The lobby client program should display this message to the user in an invasive way, which requires response from the user (for example, in a dialogue box with an OK button). */
        SERVERMSGBOX: {
            message: string;
            /** If specified, the lobby client should ask the user if he wants this URL to be opened in a browser window. The lobby client should then (once the user clicked OK) launch the default browser and open this URL in there. */
            url?: string;
        }
        /** Sent by the server to a client who requested the channels list via the CHANNELS command. A series of these commands will be sent to the client, one for each open channel. A series of CHANNEL commands is followed by the ENDOFCHANNELS command. */
        CHANNEL: {
            chanName: string;
            /** Number of users in the channel. */
            userCount: number;
            /** Is omited if the topic is not set for the channel. */
            topic?: string;
        }
        /** Sent to a client who previously requested the channel list, after a series of CHANNEL commands (one for each channel). */
        ENDOFCHANNELS: {
        }
        /** Sent to a client who has successfully JOINed a channel. The server will now send the client a CLIENTS and a CLIENTSFROM command, which together give the list of users present in the channel. */
        JOIN: {
            /** Name of the channel which the client has just joined */
            chanName: string;
        }
        /** Sent if joining a channel failed for some reason. */
        JOINFAILED: {
            chanName: string;
            reason: string;
        }
        /** Sent to a client who just JOINed a channel, or who was already present in a channel when the topic was changed. This command informs the client of the current channel topic. */
        CHANNELTOPIC: {
            chanName: string;
            author: string;
            topic: string;
        }
        /**
         * Sent to a client who just joined the channel. This command informs the client of the list of users present in the channel, including the client itself.
         *
         * This command is always sent (to a client joining a channel), and the list it conveys includes the newly joined client. It is sent after all the CLIENTSFROM commands. Once CLIENTS has been processed, the joining client has been informed of the full list of other clients and bridged clients currently present in the joined channel.
         */
        CLIENTS: {
            chanName: string;
            clients: string[];
        }
        /** Sent to all clients in a channel (except the new client) when a new user joins the channel. */
        JOINED: {
            chanName: string;
            userName: string;
        }
        /** Sent by the server to inform a client, present in a channel, that another user has left that channel. */
        LEFT: {
            chanName: string;
            userName: string;
            reason?: string;
        }
        /** Sent by the server to all clients in a channel. Used to broadcast messages in a channel. */
        CHANNELMESSAGE: {
            chanName: string;
            message: string;
        }
        /** Sent to all clients participating in a specific channel when one of the clients sent a chat message to it (including the author of the message). */
        SAID: {
            chanName: string;
            userName: string;
            message: string;
        }
        /** Sent by the server when a client said something using the SAYEX command. */
        SAIDEX: {
            chanName: string;
            userName: string;
            message: string;
        }
        /** Sent to a client that just sent a SAYPRIVATE command. This notifies the client that the server sent the private message on to its intended recipient. */
        SAYPRIVATE: {
            userName: string;
            message: string;
        }
        /** Sends a private message on to its intended recipient. */
        SAIDPRIVATE: {
            username: string;
            message: string;
        }
        /** Sent to a client that just sent a SAYPRIVATE command. This notifies the client that the server sent the private message on to its intended recipient. */
        SAYPRIVATEEX: {
            userName: string;
            message: string;
        }
        /** Sends a private message in "/me" IRC style on to its intended recipient. */
        SAIDPRIVATEEX: {
            userName: string;
            message: string;
        }
        /**
         * Sent by the server in response to a successful BRIDGECLIENTFROM command.
         *
         * The server will use 'externalUser:location' as the username for the bridged client.
         */
        BRIDGEDCLIENTFROM: {
            location: string;
            externalId: number;
            externalUsername: string;
        }
        /** Sent by the server in response to a successful UNBRIDGECLIENTFROM command. */
        UNBRIDGEDCLIENTFROM: {
            location: string;
            externalId: number;
            externalUsername: string;
        }
        /** Sent by the server in response to a successful JOINFROM command. */
        JOINEDFROM: {
            chan: string;
            /** The username of the bridge bot for this bridged client. */
            bridge: string;
            /** This will have the form externalUsername:location. */
            userName: string;
        }
        /** Sent by the server in response to a successful LEFTFROM command. */
        LEFTFROM: {
            chan: string;
            userName: string;
        }
        /** Sent by the server in response to a successful SAYFROM command. */
        SAIDFROM: {
            chan: string;
            /** This will have the form externalUsername:location. */
            userName: string;
            message?: string;
        }
        /** Sent by the server to a (non-bridged) client who just joined a channel. */
        CLIENTSFROM: {
            chan: string;
            /** The username of the bridge bot for the following clients. */
            bridge: string;
            /** A list of usernames of clients who are bridged into this channel. */
            clients: string[];
        }
        /** Informs a client that tried to open a battle that their request has been rejected. */
        OPENBATTLEFAILED: {
            reason: string;
        }
        /** */
        BATTLEOPENED: {
            battleId: number;
            type: number;
            natType: number;
            founder: string;
            ip: string;
            port: number;
            maxPlayers: string;
            passworded: boolean;
            rank: number;
            mapHash: number;
            engineName: string;
            engineVersion: string;
            map: string;
            title: string;
            gameName: string;
            /** The name of the channel (which will contain no whitespace) in which the chat for this battle takes place. By convention, these channels have names of the form __battle__1234. */
            channel?: string;
        }
        /**
         * Sent to a client who previously sent an OPENBATTLE command, if the client's request to open a new battle has been approved.
         *
         * Note that the corresponding BATTLEOPENED command is sent before this command is used to reflect the successful OPENBATTLE command back to the client.
         *
         * After sending this command, the server will send a JOINBATTLE (to notify the founding client that they have joined their own battle) followed by a REQUESTBATTLESTATUS.
        */
        OPENBATTLE: {
            battleId: number;
        }
        /**
         * Notifies a client that their request to JOINBATTLE was successful, and that they have just joined the battle.
         *
         * Clients in the battle will be notified of the new user via JOINEDBATTLE.
         *
         * Next, the server will send a series of commands to the newly joined client, which might include DISABLEUNITS, ADDBOT, ADDSTARTRECT, SETSCRIPTTAGS and so on, along with multiple CLIENTBATTLESTATUS, in order to describe the current state of the battle to the joining client.
         *
         * If the battle has natType>0, the server will also send the clients IP port to the host, via the CLIENTIPPORT command. Someone who knows more about this should write more!
        */
        JOINBATTLE: {
            battleId: number;
            hashCode: number;
            channelName: string;
        }
        /** Sent by the server to a battle host, each time a client requests to join his battle. */
        JOINBATTLEREQUEST: {
            userName: string;
            ip: string;
        }
        /** Notifies a client that their request to JOINBATTLE was denied. */
        JOINBATTLEFAILED: {
            reason: string;
        }
        /**
         * Sent by the server to all clients when a new client joins the battle.
         *
         * The server does not send this command for a host, when that host opens its own battle.
        */
        JOINEDBATTLE: {
            battleId: number;
            userName: string;
            /** A random, client-generated string, wich will be written to script.txt by the host, to avoid account spoofing (= someone is trying to join the battle under a wrong user-name). */
            scriptPassword?: string;
        }
        /** Sent by the server to all users when a client left a battle (or got disconnected from the server). */
        LEFTBATTLE: {
            battleId: number;
            userName: string;
        }
        /** Sent to all users to notify that a battle has been closed. */
        BATTLECLOSED: {
            battleId: number;
        }
        /**
         * Sent as a response to a client's UDP packet (used with "hole punching" NAT traversal technique).
         *
         * Someone who knows more about this should document it!
         * */
        UDPSOURCEPORT: {
            port: number;
        }
        /** Sent to the battle's host, notifying him about another client's IP address and his public UDP source port. */
        CLIENTIPPORT: {
            userName: string;
            ip: string;
            port: number;
        }
        /** Sent by the server to all clients participating in the battle, except for the host, notifying them about the (possibly new) host port. */
        HOSTPORT: {
            port: number;
        }
        /** Sent by the server to all registered clients, telling them some of the parameters of the battle changed. A battle's internal changes, like starting metal, energy, starting position etc., are sent only to clients participating in the battle (via the SETSCRIPTTAGS command). */
        UPDATEBATTLEINFO: {
            battleId: number;
            /** Assume that spectator count is 0, if battle type is 0 (normal battle) and 1 if battle type is 1 (battle replay), as the founder of the battle is automatically set as a spectator in that case. */
            spectatorCount: number;
            /**  A boolean ("0" (for false) or "1"). Note that when the client creates a battle, the server assumes it is unlocked (by default). The client must make sure it assumes this same default. */
            locked: boolean;
            /** A signed 32-bit integer. See the OPENBATTLE command for more info. */
            mapHash: number;
            mapName: string;
        }
        /** Sent by the server to all registered clients, indicating that a client's status changed. Note that client's status is considered 0 if not indicated otherwise (for example, when you login, the server sends only statuses of those clients whose statuses differ from 0, to save bandwidth). */
        CLIENTSTATUS: {
            userName: string;
            /** See the MYSTATUS command for possible values of this parameter. */
            status: string;
        }
        /** Sent by the server to users participating in a battle when one of the clients changes his battle status. */
        CLIENTBATTLESTATUS: {
            userName: string;
            /** See the MYBATTLESTATUS command for possible values of this argument. */
            battleStatus: string;
            /** Uses the same format as the one used with the MYBATTLESTATUS command. */
            teamColor: number;
        }
        /** Sent by the server to a user which just opened a battle or joined one. Sent after all CLIENTBATTLESTATUS commands for all clients have been sent. */
        REQUESTBATTLESTATUS: {
        }
        /** Sent by the server to notify the battle host that the named user should be kicked from the battle in progress. */
        KICKFROMBATTLE: {
            battleId: number;
            userName: string;
        }
        /**
         * Sent to a client that was kicked from their current battle by the battle founder.
         *
         * The client does not need to send LEAVEBATTLE, as removal has already been done by the server. The only purpose of this command is to notify the client that they were kicked. (The client will also recieve a corresponding LEFTBATTLE notification.)
         */
        FORCEQUITBATTLE: {
        }
        /** Sent by the server to all clients in a battle, telling them that some units have been added to disabled units list. Also see the DISABLEUNITS command. */
        DISABLEUNITS: {
            unitNames: string[];
        }
        /** Sent by the server to all clients in a battle, telling them that some units have been added to enabled units list. Also see the DISABLEUNITS command. */
        ENABLEUNITS: {
            unitNames: string[];
        }
        /** Sent by the server to all clients in a battle, telling them that the disabled units list has been cleared. */
        ENABLEALLUNITS: {
        }
        /** Sent to notify a client that another user requested that a "ring" sound be played to them. */
        RING: {
            userName: string;
        }
        /** Indicates that a client has added a bot to the battle. */
        ADDBOT: {
            /** helps the client verify that the bot is meant for his battle. */
            battleId: number;
            name: string;
            owner: string;
            battleStatus: string;
            /** Should be 32-bit signed integer in decimal form (e.g. 255 and not FF) where each color channel should occupy 1 byte (e.g. in hexdecimal: $00BBGGRR, B = blue, G = green, R = red). */
            teamColor: number;
            aiDll: string;
        }
        /** Indicates that a bot has been removed from the battle. */
        REMOVEBOT: {
            /** helps the client verify that the bot is meant for his battle. */
            battleId: number;
            name: string;
        }
        /** Sent by the server notifying a client in the battle that one of the bots just got his status updated. Also see the UPDATEBOT command. */
        UPDATEBOT: {
            /** helps the client verify that the bot is meant for his battle. */
            battleId: number;
            name: string;
            /** Similar to that of the normal client's, see MYSTATUS for more info. */
            battleStatus: string;
            teamColor: number;
        }
        /** Sent by the server to clients participating in a battle (except for the host). See lobby client implementations and Spring docs for more info on this one. "left", "top", "right" and "bottom" refer to a virtual rectangle that is 200x200 in size, where coordinates should be in the interval [0, 200]. */
        ADDSTARTRECT: {
            allyNo: number;
            left: number;
            top: number;
            right: number;
            bottom: number;
        }
        /** Removing a start rectangle the for 'allyNo' ally team. Sent to clients participating in a battle (except for the host). Also see ADDSTARTRECT command. */
        REMOVESTARTRECT: {
            allyNo: number;
        }
        /** Relayed from battle host's SETSCRIPTTAGS message. A client lobby program must process these tags and apply them accordingly to the GUI presenting current battle configuration to the player. All keys are made lowercase by the server. */
        SETSCRIPTTAGS: {
            pairs: string[];
        }
        /** Relayed from battle host's REMOVESCRIPTTAGS message. A client lobby program has to remove these from the GUI presenting current battle configuration to the player. */
        REMOVESCRIPTTAGS: {
            keys: string[];
        }
        /** Tells the client that the user has been ignored (usually as a result of the IGNORE command sent by the client, but other sources are also possible). Also see the IGNORE command. This command uses named arguments, see "Named Arguments" chapter of the Intro section. */
        IGNORE: {
            /** The username of the ignored user. */
            userName: string;
            /** Reason for the ignore. */
            reason?: string;
        }
        /** Tells the client that the user has been unignored (usually as a result of the UNIGNORE command sent by the client, but other sources are also possible). Also see the UNIGNORE command. This command uses named arguments, see "Named Arguments" chapter of the Intro section. */
        UNIGNORE: {
            /** The username of the unignored user. */
            userName: string;
        }
        /** Sent by the server when sending the ignore list to the client. */
        IGNORELISTBEGIN: {
        }
        /** Multiple commands of this kind may be sent after a IGNORELISTBEGIN command (or none, if the ignore list is empty). This command uses named arguments, see "Named Arguments" chapter of the Intro section. */
        IGNORELIST: {
            /** The username of the user to be ignored. */
            userName: string;
            /** Reason for the ignore. */
            reason?: string;
        }
        /** Sent by the server after it has finished sending the ignore list for a client. Also see the IGNORELIST and IGNORELISTBEGIN commands. */
        IGNORELISTEND: {
        }
        /** Sent as a response to a LISTCOMPFLAGS command. The server sends a list of supported comp-flags that may be specified by the client on LOGIN. */
        COMPFLAGS: {
            compFlags: string[];
        }
        /** Sent by the server when running in "redirection mode". When a client connects, the server will send him only this message and disconnect the socket immediately. The client should connect to the given IP and port, in that case. This command may be useful when the official server ip/address changes, so that clients are automatically redirected to the new one. */
        REDIRECT: {
            ip: string;
            port: number;
        }
        /** A command used to notify that a command sent to the server has either failed, been denied, or otherwise cannot be completed. This normally is used as a generic error command, to inform lobby/client developers that they have not used the protocol correctly. */
        FAILED: {
        }
        /** A command used to send information to clients in JSON format. (Currently rarely used.) */
        JSON: {
        }
    }
}

// export enum ServerMode {
//     NORMAL = 0,
//     LAN = 1
// }

// export enum CompatabilityFlags {

// }

// export enum BattleType {
//     NORMAL = 0,
//     REPLAY = 1
// }

// export enum NATType {
//     NONE = 0,
//     HOLE_PUNCHING = 1,
//     FIXED_SOURCE_PORTS = 2
// }